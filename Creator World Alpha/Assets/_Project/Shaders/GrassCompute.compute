// Grass Compute Shader
// Handles grass instance culling and LOD selection on GPU

#pragma kernel ResetArgs
#pragma kernel CullGrass

// Structures
struct GrassInstance
{
    float4x4 trs;           // Transform matrix
    float density;          // Density at this position (for scaling)
};

struct VisibleInstance
{
    uint instanceIndex;     // Index into grass buffer
    uint lodIndex;          // 0, 1, or 2
};

struct SubChunk
{
    float3 center;          // World space center
    float3 extents;         // Half-size for AABB
    uint startIndex;        // Start index in grass buffer
    uint count;             // Number of instances in this sub-chunk
};

// Buffers
StructuredBuffer<GrassInstance> _GrassBuffer;
StructuredBuffer<SubChunk> _SubChunkBuffer;
AppendStructuredBuffer<VisibleInstance> _VisibleBuffer;
RWStructuredBuffer<uint> _ArgsBuffer;

// Textures
Texture2D<float> _DepthTexture;
SamplerState sampler_DepthTexture;

// Parameters
float4x4 _ViewProjection;
float4 _FrustumPlanes[6];
float3 _CameraPosition;
float _MaxViewDistance;
float _LOD1Threshold;
float _LOD2Threshold;
float _OcclusionDepthBias;
uint _SubChunkCount;
uint _TotalInstances;
bool _UseOcclusionCulling;

// Helper functions
float PlaneDistance(float4 plane, float3 position)
{
    return dot(plane.xyz, position) + plane.w;
}

bool IsInFrustum(float3 center, float3 extents)
{
    // Test AABB against all 6 frustum planes
    for (int i = 0; i < 6; i++)
    {
        float4 plane = _FrustumPlanes[i];

        // Get the positive vertex (furthest along plane normal)
        float3 positive = center;
        positive.x += (plane.x >= 0) ? extents.x : -extents.x;
        positive.y += (plane.y >= 0) ? extents.y : -extents.y;
        positive.z += (plane.z >= 0) ? extents.z : -extents.z;

        // If positive vertex is behind plane, AABB is completely outside
        if (PlaneDistance(plane, positive) < 0)
            return false;
    }
    return true;
}

bool IsOccluded(float3 position)
{
    if (!_UseOcclusionCulling)
        return false;

    // Project to screen space
    float4 clipPos = mul(_ViewProjection, float4(position, 1.0));

    // Behind camera
    if (clipPos.w <= 0)
        return true;

    // Perspective divide
    float3 ndc = clipPos.xyz / clipPos.w;

    // Outside NDC bounds
    if (abs(ndc.x) > 1.0 || abs(ndc.y) > 1.0)
        return false; // Don't cull if outside screen

    // Convert to UV (0-1)
    float2 uv = ndc.xy * 0.5 + 0.5;
    uv.y = 1.0 - uv.y; // Flip Y

    // Sample depth
    float sceneDepth = _DepthTexture.SampleLevel(sampler_DepthTexture, uv, 0).r;
    float instanceDepth = ndc.z;

    // Calculate adaptive bias
    float distance = length(position - _CameraPosition);
    float adaptiveBias = _OcclusionDepthBias * (1.0 + distance / _MaxViewDistance);

    // Compare depths (reversed Z buffer: larger = closer)
    #if UNITY_REVERSED_Z
        return instanceDepth < sceneDepth - adaptiveBias;
    #else
        return instanceDepth > sceneDepth + adaptiveBias;
    #endif
}

uint GetLODIndex(float distance)
{
    float ratio = distance / _MaxViewDistance;
    if (ratio < _LOD1Threshold) return 0;
    if (ratio < _LOD2Threshold) return 1;
    return 2;
}

// Kernel: Reset indirect draw args
[numthreads(1, 1, 1)]
void ResetArgs(uint3 id : SV_DispatchThreadID)
{
    // Reset instance count to 0
    // Args buffer layout: [indexCount, instanceCount, indexStart, baseVertex, instanceStart]
    _ArgsBuffer[1] = 0;
}

// Kernel: Cull grass instances
[numthreads(32, 1, 1)]
void CullGrass(uint3 id : SV_DispatchThreadID)
{
    uint subChunkIndex = id.x;
    if (subChunkIndex >= _SubChunkCount)
        return;

    SubChunk chunk = _SubChunkBuffer[subChunkIndex];

    // Skip empty chunks
    if (chunk.count == 0)
        return;

    // Distance check (early out)
    float distance = length(chunk.center - _CameraPosition);
    if (distance > _MaxViewDistance)
        return;

    // Frustum culling
    if (!IsInFrustum(chunk.center, chunk.extents))
        return;

    // Occlusion culling (test chunk corners)
    if (_UseOcclusionCulling)
    {
        // Test center point for quick occlusion check
        float3 testPoint = chunk.center + float3(0, chunk.extents.y, 0);
        if (IsOccluded(testPoint))
            return;
    }

    // Determine LOD for this chunk
    uint lodIndex = GetLODIndex(distance);

    // Add all instances in this chunk to visible buffer
    for (uint i = 0; i < chunk.count; i++)
    {
        uint instanceIndex = chunk.startIndex + i;
        if (instanceIndex >= _TotalInstances)
            break;

        VisibleInstance visible;
        visible.instanceIndex = instanceIndex;
        visible.lodIndex = lodIndex;

        _VisibleBuffer.Append(visible);

        // Increment instance count atomically
        InterlockedAdd(_ArgsBuffer[1], 1);
    }
}
